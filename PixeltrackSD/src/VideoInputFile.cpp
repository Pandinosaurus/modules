/*
Copyright (C) 2013 Stefan Duffner, LIRIS, INSA de Lyon, France

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifdef USE_DEPRECATED_AVFORMAT
	// Ubuntu < 14.04 only
	extern "C" {
	  #include <libavformat/avformat.h>
	}
#endif
#include "VideoInputFile.h"

namespace TLInOut
{

VideoInputFile::VideoInputFile(string filename, float fps/*=-1*/)
{
  msFilename = filename;
  mbFrameGrabbed = false;
  mbNextImageAvailable = false;
  mCapture = new cv::VideoCapture();
  if (!mCapture->open(msFilename))
  {
    delete mCapture;
    throw TLUtil::FileOpen_Ex(msFilename);
  }
  if (fps>0)
    mfFPS = fps;
  else
  { 
    mfFPS = mCapture->get(CV_CAP_PROP_FPS);
    if (mfFPS<=0)
    {
      mCapture->release();

      if (determineFPS_ffmpeg(msFilename)!=0)
      {
        mfFPS=25;
        MESSAGE(1, "Couldn't retrieve FPS information. Assuming " << mfFPS << "fps");
      }

      mCapture->open(msFilename);
    }
  }
}

VideoInputFile::~VideoInputFile()
{
  delete mCapture;
}


bool VideoInputFile::nextImageAvailable()
{
  if (!mbFrameGrabbed)
  {
    if (mCapture->grab())
    {
      mbNextImageAvailable=true;
      mbFrameGrabbed=true;
      return true;
    }
    return false;
  }
  else
    return mbNextImageAvailable;
}


Image<unsigned char>* VideoInputFile::nextImage()
{
  if (!nextImageAvailable())
    return NULL;

  if (!mCapture->retrieve(mFrame))
    return NULL;
  
  Image<unsigned char>* newimage = new Image<unsigned char>(mFrame.cols, mFrame.rows, 3, mFrame.step, mFrame.data);

  VideoInput::miFramesRead++;
  mbFrameGrabbed=false;
  return newimage;
}


int VideoInputFile::determineFPS_ffmpeg(string filename)
{
#ifdef USE_DEPRECATED_AVFORMAT
	// Works on Ubuntu 12.04
    AVFormatContext *pFormatCtx;
    int i, videoStream;
    AVCodecContext *pCodecCtx;

    if(av_open_input_file(&pFormatCtx, filename.c_str(), NULL, 0, NULL)!=0)
      return -1;


    if (av_find_stream_info(pFormatCtx)<0)
    {
      av_close_input_file(pFormatCtx);
      return -2;
    }


    // Find the first video stream
    videoStream=-1;
    for(i=0; i<(int)pFormatCtx->nb_streams; i++)
      //if(pFormatCtx->streams[i]->codec->codec_type==CODEC_TYPE_VIDEO)
      if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO)
      {
        videoStream=i;
        break;
      }
    if(videoStream==-1)
    {
      av_close_input_file(pFormatCtx);
      return -3;
    }

    // Get a pointer to the codec context for the video stream
    pCodecCtx=pFormatCtx->streams[videoStream]->codec;

    // Hack to correct wrong frame rates that seem to be generated by some 
    // codecs
    //if(pCodecCtx->frame_rate>1000 && pCodecCtx->frame_rate_base==1)
      //pCodecCtx->frame_rate_base=1000;

    mfFPS = (float)pCodecCtx->time_base.den/pCodecCtx->time_base.num;

    if (mfFPS<=0 || mfFPS>500)
    {
      av_close_input_file(pFormatCtx);
      return -4;
    }

    av_close_input_file(pFormatCtx);
    return 0;
#else
	// Windows & Ubuntu >= 14.04
	return -4;
#endif
}



}

